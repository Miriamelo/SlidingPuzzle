// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  var SimpleSliding, Sliding, isArray, origin, toPos;

  isArray = function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  toPos = function(posid) {
    if (isArray(posid)) {
      return posid;
    } else {
      return this.position[posid];
    }
  };

  origin = function(id, cols) {
    return [Math.floor(id / cols), id % cols];
  };

  Sliding = (function() {
    var solvable;

    Sliding.prototype._countInversions = function(array, start, end) {
      var count, l, leftCount, leftSortedArray, middle, r, rightCount, rightSortedArray, sortedArray, _ref, _ref1;
      start = start != null ? start : 0;
      end = end != null ? end : array.length - 1;
      if (start > end) {
        return [0, []];
      } else if (start === end) {
        if (isArray(array[start])) {
          return this._countInversions(array[start]);
        } else {
          if (array[start] === this.emptyID) {
            return [0, []];
          } else {
            return [0, [array[start]]];
          }
        }
      }
      middle = Math.floor(start + (end - start) / 2);
      _ref = this._countInversions(array, start, middle), leftCount = _ref[0], leftSortedArray = _ref[1];
      _ref1 = this._countInversions(array, middle + 1, end), rightCount = _ref1[0], rightSortedArray = _ref1[1];
      l = 0;
      r = 0;
      count = 0;
      sortedArray = [];
      while (l < leftSortedArray.length && r < rightSortedArray.length) {
        if (leftSortedArray[l] <= rightSortedArray[r]) {
          sortedArray.push(leftSortedArray[l]);
          l += 1;
        } else {
          sortedArray.push(rightSortedArray[r]);
          count += leftSortedArray.length - l;
          r += 1;
        }
      }
      while (l < leftSortedArray.length) {
        sortedArray.push(leftSortedArray[l]);
        l += 1;
      }
      while (r < rightSortedArray.length) {
        sortedArray.push(rightSortedArray[r]);
        r += 1;
      }
      return [leftCount + count + rightCount, sortedArray];
    };

    solvable = function(inversions, rows, cols, emptyRow) {
      return ((cols % 2 !== 0) && (inversions % 2 === 0)) || ((cols % 2 === 0) && ((rows - emptyRow + 1) % 2 !== inversions % 2));
    };

    function Sliding(rows, cols, emptyPos) {
      var col, id, row, _i, _j, _ref, _ref1, _ref2, _ref3;
      if (!rows >= 1) {
        throw RangeError('At least 1 row is required');
      }
      if (!cols >= 1) {
        throw RangeError('At least 1 col is required');
      }
      emptyPos = [emptyPos && (emptyPos[0] != null) ? emptyPos[0] : rows - 1, emptyPos && (emptyPos[1] != null) ? emptyPos[1] : cols - 1];
      if (!((0 <= (_ref = emptyPos[0]) && _ref < rows))) {
        throw RangeError('Invalid empty row');
      }
      if (!((0 <= (_ref1 = emptyPos[1]) && _ref1 < cols))) {
        throw RangeError('Invalid empty col');
      }
      this.rows = rows;
      this.cols = cols;
      this.grid = [];
      this.position = [];
      id = 0;
      for (row = _i = 0, _ref2 = rows - 1; 0 <= _ref2 ? _i <= _ref2 : _i >= _ref2; row = 0 <= _ref2 ? ++_i : --_i) {
        this.grid[row] = [];
        for (col = _j = 0, _ref3 = cols - 1; 0 <= _ref3 ? _j <= _ref3 : _j >= _ref3; col = 0 <= _ref3 ? ++_j : --_j) {
          this.grid[row][col] = id;
          this.position[id] = [row, col];
          if (row === emptyPos[0] && col === emptyPos[1]) {
            this.emptyID = id;
          }
          id += 1;
        }
      }
      this.incompletions = 0;
      return this;
    }

    Sliding.prototype.solvable = function() {
      var erow, inversions, _, _ref, _ref1;
      _ref = this.position[this.emptyID], erow = _ref[0], _ = _ref[1];
      _ref1 = this._countInversions(this.grid), inversions = _ref1[0], _ = _ref1[1];
      return solvable(inversions, this.rows, this.cols, erow + 1);
    };

    Sliding.prototype.completed = function() {
      return this.incompletions === 0;
    };

    Sliding.prototype.shuffle = function(handler) {
      var lastID, randID, _i, _ref;
      for (lastID = _i = _ref = this.rows * this.cols - 1; _ref <= 0 ? _i <= 0 : _i >= 0; lastID = _ref <= 0 ? ++_i : --_i) {
        if (lastID === this.emptyID) {
          continue;
        }
        randID = Math.floor(Math.random() * (lastID + 1));
        if (randID === this.emptyID) {
          randID += 1;
        }
        if (handler != null) {
          handler.call(this, lastID, randID);
        }
        this.swap(lastID, randID);
      }
      if (!this.solvable()) {
        console.assert(this.rows * this.cols > 2, 'It is impossible to be unsolvable');
        if (this.emptyID === 0) {
          if (handler != null) {
            handler.call(this, 1, 2);
          }
          this.swap(1, 2);
        } else if (this.emptyID === 1) {
          if (handler != null) {
            handler.call(this, 0, 2);
          }
          this.swap(0, 2);
        } else {
          if (handler != null) {
            handler.call(this, 0, 1);
          }
          this.swap(0, 1);
        }
      }
      return this;
    };

    Sliding.prototype.swap = function(p1, p2) {
      var id1, id2, ox, oy, x1, x2, y1, y2, _ref, _ref1, _ref2, _ref3;
      if (p1 === p2) {
        return this;
      }
      _ref = toPos.call(this, p1), y1 = _ref[0], x1 = _ref[1];
      _ref1 = toPos.call(this, p2), y2 = _ref1[0], x2 = _ref1[1];
      if (x1 === x2 && y1 === y2) {
        return this;
      }
      id1 = this.grid[y1][x1];
      id2 = this.grid[y2][x2];
      this.grid[y1][x1] = id2;
      this.grid[y2][x2] = id1;
      this.position[id1] = [y2, x2];
      this.position[id2] = [y1, x1];
      _ref2 = origin(id1, this.cols), oy = _ref2[0], ox = _ref2[1];
      if (oy === y1 && ox === x1) {
        this.incompletions += 1;
      }
      if (oy === y2 && ox === x2) {
        this.incompletions -= 1;
      }
      _ref3 = origin(id2, this.cols), oy = _ref3[0], ox = _ref3[1];
      if (oy === y2 && ox === x2) {
        this.incompletions += 1;
      }
      if (oy === y1 && ox === x1) {
        this.incompletions -= 1;
      }
      return this;
    };

    Sliding.prototype.slide = function(posid, handler) {
      var c, col, ecol, erow, r, row, startCol, startRow, _i, _j, _ref, _ref1;
      if (!this.slidable(posid)) {
        return this;
      }
      _ref = toPos.call(this, posid), row = _ref[0], col = _ref[1];
      _ref1 = this.position[this.emptyID], erow = _ref1[0], ecol = _ref1[1];
      if (row === erow) {
        startCol = ecol + (ecol > col ? -1 : 1);
        for (c = _i = startCol; startCol <= col ? _i <= col : _i >= col; c = startCol <= col ? ++_i : --_i) {
          if (handler != null) {
            handler.call(this, this.grid[row][c], this.emptyID);
          }
          this.swap([row, c], this.emptyID);
        }
      } else if (col === ecol) {
        startRow = erow + (erow > row ? -1 : 1);
        for (r = _j = startRow; startRow <= row ? _j <= row : _j >= row; r = startRow <= row ? ++_j : --_j) {
          if (handler != null) {
            handler.call(this, this.grid[r][col], this.emptyID);
          }
          this.swap([r, col], this.emptyID);
        }
      }
      return this;
    };

    Sliding.prototype.slidable = function(posid) {
      var col, ecol, erow, row, _ref, _ref1;
      _ref = toPos.call(this, posid), row = _ref[0], col = _ref[1];
      _ref1 = this.position[this.emptyID], erow = _ref1[0], ecol = _ref1[1];
      return ((0 <= row && row < this.rows) && (0 <= col && col < this.cols)) && !(row === erow && col === ecol) && (row === erow || col === ecol);
    };

    Sliding.prototype.mapPos = function(f) {
      var col, results, row, _i, _j, _ref, _ref1;
      results = [];
      for (row = _i = 0, _ref = this.rows - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; row = 0 <= _ref ? ++_i : --_i) {
        for (col = _j = 0, _ref1 = this.cols - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; col = 0 <= _ref1 ? ++_j : --_j) {
          if (this.grid[row][col] !== this.emptyID) {
            results.push(f.call(this, [row, col]));
          }
        }
      }
      return results;
    };

    Sliding.prototype.mapID = function(f) {
      var id, results, _i, _ref;
      results = [];
      for (id = _i = 0, _ref = this.rows * this.cols - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; id = 0 <= _ref ? ++_i : --_i) {
        if (id !== this.emptyID) {
          results.push(f.call(this, id));
        }
      }
      return results;
    };

    return Sliding;

  })();

  SimpleSliding = (function() {
    var base, createSquare;

    base = Sliding;

    createSquare = function(id) {
      var square;
      square = document.createElement('div');
      square.setAttribute('data-id', id);
      square.style.position = 'absolute';
      return square;
    };

    function SimpleSliding() {
      base.apply(this, arguments);
    }

    SimpleSliding.prototype = Object.create(base.prototype);

    SimpleSliding.prototype.constructor = SimpleSliding;

    SimpleSliding.prototype._getWidth = function(col) {
      if (col < this.colResidual) {
        return this.sqWidth + 1;
      } else {
        return this.sqWidth;
      }
    };

    SimpleSliding.prototype._getHeight = function(row) {
      if (row < this.rowResidual) {
        return this.sqHeight + 1;
      } else {
        return this.sqHeight;
      }
    };

    SimpleSliding.prototype._getLeft = function(col) {
      var baseLeft, residual;
      baseLeft = col * (this.sqWidth + this.spacing);
      residual = col < this.colResidual ? col : this.colResidual;
      return baseLeft + residual;
    };

    SimpleSliding.prototype._getTop = function(row) {
      var baseTop, residual;
      baseTop = row * (this.sqHeight + this.spacing);
      residual = row < this.rowResidual ? row : this.rowResidual;
      return baseTop + residual;
    };

    SimpleSliding.prototype._getBackgroundX = function(origCol, col) {
      var x;
      x = -1 * this._getLeft(origCol);
      if (origCol === this.cols - 1 && col < this.colResidual) {
        x += 1;
      }
      return x;
    };

    SimpleSliding.prototype._getBackgroundY = function(origRow, row) {
      var y;
      y = -1 * this._getTop(origRow);
      if (origRow === this.rows - 1 && row < this.rowResidual) {
        y += 1;
      }
      return y;
    };

    SimpleSliding.prototype._putSquare = function(id, posid) {
      var col, ocol, orow, row, style, _ref, _ref1;
      posid = posid != null ? posid : id;
      _ref = toPos.call(this, posid), row = _ref[0], col = _ref[1];
      style = this.squares[id].style;
      style.left = this._getLeft(col) + 'px';
      style.top = this._getTop(row) + 'px';
      style.width = this._getWidth(col) + 'px';
      style.height = this._getHeight(row) + 'px';
      _ref1 = origin(id, this.cols), orow = _ref1[0], ocol = _ref1[1];
      style.backgroundPosition = "" + (this._getBackgroundX(ocol, col)) + "px " + (this._getBackgroundY(orow, row)) + "px";
      return this;
    };

    SimpleSliding.prototype.render = function(element, spacing) {
      var board, boardHeight, boardWidth, id, square, _ref;
      if (element != null) {
        board = document.createElement('div');
        board.style.position = 'relative';
        board.style.width = '100%';
        board.style.height = '100%';
        element.appendChild(board);
        this.board = board;
        this.element = element;
      }
      if (spacing != null) {
        this.spacing = spacing;
      }
      if (this.spacing == null) {
        this.spacing = 0;
      }
      boardHeight = this.board.clientHeight - this.spacing * (this.rows - 1);
      boardWidth = this.board.clientWidth - this.spacing * (this.cols - 1);
      this.sqWidth = Math.floor(boardWidth / this.cols);
      this.sqHeight = Math.floor(boardHeight / this.rows);
      this.colResidual = boardWidth % this.cols;
      this.rowResidual = boardHeight % this.rows;
      if (element != null) {
        this.squares = this.mapID(createSquare);
      }
      _ref = this.squares;
      for (id in _ref) {
        square = _ref[id];
        if (element != null) {
          this.board.appendChild(square);
        }
        this._putSquare(id);
      }
      return this;
    };

    SimpleSliding.prototype.shuffle = function() {
      return base.prototype.shuffle.call(this, (function(_this) {
        return function(src, tar) {
          _this._putSquare(src, tar);
          return _this._putSquare(tar, src);
        };
      })(this));
    };

    SimpleSliding.prototype.slide = function(posid) {
      return base.prototype.slide.call(this, posid, (function(_this) {
        return function(src, tar) {
          console.assert(tar === _this.emptyID, 'Target must be the empty square');
          return _this._putSquare(src, tar);
        };
      })(this));
    };

    return SimpleSliding;

  })();

  if ((typeof module !== "undefined" && module !== null) && (module.exports != null)) {
    module.exports = {
      Sliding: Sliding,
      SimpleSliding: SimpleSliding
    };
  }

  if (typeof window !== "undefined" && window !== null) {
    window.Sliding = Sliding;
    window.SimpleSliding = SimpleSliding;
  }

}).call(this);
